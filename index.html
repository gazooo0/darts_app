<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>る～れっとだーつ！</title>
  <style>
    body { display: flex; flex-direction: column; align-items: center; font-family: sans-serif; margin: 20px; }
    canvas { border: 2px solid #333; border-radius: 8px; background: #fff; cursor: pointer; }
    /* 結果表示スタイル */
    #result {
      font-size: 2em;
      font-weight: bold;
      background-color: yellow;
      color: red;
      padding: 8px 16px;
      margin-top: 12px;
      border-radius: 4px;
      min-height: 48px;
      width: 400px;
      box-sizing: border-box;
      text-align: center;
    }
    #start-control { margin-top: 12px; }
    #start-btn { font-size: 1.2em; padding: 10px 20px; }
    #controls { margin-top: 12px; display: flex; gap: 8px; justify-content: center; align-items: center; }
    table#inputs { margin-top: 12px; border-collapse: collapse; }
    table#inputs th, table#inputs td { border: 1px solid #999; padding: 4px 8px; text-align: center; }
    table#inputs th { background: #eee; }
    table#inputs input[type="text"] { width: 100px; border: none; text-align: center; }
    table#inputs input[type="color"] { border: none; width: 30px; height: 20px; padding: 0; }
    .delete-btn { background: none; border: none; color: #c00; cursor: pointer; font-size: 1em; margin-right: 4px; }
    #credits { font-size: 12px; color: #666; margin-top: 8px; }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
  </style>
</head>
<body>
  <!-- 音声素材 -->
  <audio id="drumroll" src="drumroll.mp3" loop></audio>
  <audio id="stopSound" src="stop.mp3"></audio>

  <canvas id="dartboard" width="400" height="400"></canvas>
  <div id="result"></div>

  <div id="start-control">
    <button id="start-btn">ルーレットダーツ スタート！</button>
  </div>
  <div id="controls">
    <button id="add-btn">項目を追加</button>
    <button id="update-btn">ラベルを反映</button>
  </div>

  <table id="inputs">
    <thead>
      <tr><th colspan="2">項目名・色</th><th colspan="2">項目名・色</th><th colspan="2">項目名・色</th></tr>
    </thead>
    <tbody></tbody>
  </table>

  <div id="credits">使用素材：効果音工房様・効果音ラボ様</div>

  <script>
    // DOM キャッシュ
    const canvas = document.getElementById('dartboard');
    const ctx = canvas.getContext('2d');
    const center = { x: canvas.width/2, y: canvas.height/2 };
    const radii = { inner:100, outer:180 };
    const drum = document.getElementById('drumroll');
    const stopSound = document.getElementById('stopSound');
    const tbody = document.querySelector('#inputs tbody');
    const startBtn = document.getElementById('start-btn');
    const addBtn = document.getElementById('add-btn');
    const updateBtn = document.getElementById('update-btn');

    // 状態
    let segments = [];
    let colors = [];
    let rotation = 0;
    let velocity = 0;
    let decelerating = false;
    let clickPos = null;
    let animId;
    // 入力要素キャッシュ
    let segInputs = [];
    let colInputs = [];

    const defaultColors = ['#ff6666','#66ff66','#6666ff','#ff66ff','#66ffff','#ffff66','#ff9966','#9966ff','#66ff99','#cc66cc'];
    const DECELERATION = 0.95;
    const STOP_THRESHOLD = 0.02;
    const INITIAL_COUNT = 3;

    function init() {
      segments = [];
      colors = [];
      for (let i = 0; i < INITIAL_COUNT; i++) addEntry();
      rebuildTable();
      bindEvents();
      animate();
    }

    function bindEvents() {
      addBtn.addEventListener('click', addEntry);
      updateBtn.addEventListener('click', () => {
        if (velocity !== 0) return;
        drawBoard();
        document.getElementById('result').textContent = '';
      });
      startBtn.addEventListener('click', () => {
        // 最新配列で開始
        velocity = 0.3; decelerating = false;
        drum.currentTime = 0; drum.play().catch(() => {});
        startBtn.disabled = true;
        cancelAnimationFrame(animId);
        animate();
      });
      canvas.addEventListener('click', e => {
        if (velocity === 0) return;
        drum.pause(); drum.currentTime = 0;
        stopSound.currentTime = 0; stopSound.play().catch(() => {});
        const rect = canvas.getBoundingClientRect();
        clickPos = { x: e.clientX - rect.left, y: e.clientY - rect.top };
        decelerating = true;
      });
    }

    function addEntry() {
      const idx = segments.length;
      segments.push((idx + 1).toString());
      colors.push(defaultColors[idx % defaultColors.length]);
      rebuildTable();
    }

    function rebuildTable() {
      // ドキュメントフラグメント利用
      const frag = document.createDocumentFragment();
      segInputs = [];
      colInputs = [];
      const cols = 3;
      segments.forEach((seg, index) => {
        const rowIndex = Math.floor(index / cols);
        let tr = frag.children[rowIndex];
        if (!tr) {
          tr = document.createElement('tr');
          frag.appendChild(tr);
        }
        // ラベル入力セル
        const tdLabel = document.createElement('td');
        const delBtn = document.createElement('button');
        delBtn.className = 'delete-btn'; delBtn.textContent = '×'; delBtn.dataset.idx = index;
        tdLabel.appendChild(delBtn);
        const inp = document.createElement('input');
        inp.className = 'segment-input'; inp.type = 'text'; inp.value = seg;
        tdLabel.appendChild(inp);
        segInputs.push(inp);
        tr.appendChild(tdLabel);
        // カラー入力セル
        const tdColor = document.createElement('td');
        const cinp = document.createElement('input');
        cinp.className = 'color-input'; cinp.type = 'color'; cinp.value = colors[index];
        tdColor.appendChild(cinp);
        colInputs.push(cinp);
        tr.appendChild(tdColor);
      });
      tbody.replaceChildren(frag);
      attachDeleteEvents();
      attachInputEvents();
    }

    function attachInputEvents() {
      segInputs.forEach((inp, i) => {
        inp.addEventListener('input', e => {
          segments[i] = e.target.value.trim() || '-';
        });
      });
      colInputs.forEach((inp, i) => {
        inp.addEventListener('input', e => {
          colors[i] = e.target.value;
        });
      });
    }

    function attachDeleteEvents() {
      Array.from(tbody.querySelectorAll('.delete-btn')).forEach(btn => {
        btn.addEventListener('click', e => {
          const idx = parseInt(btn.dataset.idx, 10);
          segments.splice(idx, 1);
          colors.splice(idx, 1);
          rebuildTable();
          drawBoard();
        });
      });
    }

    function drawBoard() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.save(); ctx.translate(center.x, center.y); ctx.rotate(rotation);
      const count = segments.length;
      if (count) {
        const angleStep = 2 * Math.PI / count;
        segments.forEach((seg, i) => {
          ctx.beginPath(); ctx.fillStyle = colors[i];
          ctx.moveTo(0, 0);
          ctx.arc(0, 0, radii.outer, i * angleStep, (i + 1) * angleStep);
          ctx.closePath(); ctx.fill();
        });
      }
      ctx.restore();
      ctx.fillStyle = '#000'; ctx.font = '14px sans-serif';
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      segments.forEach((seg, i) => {
        const angleStep = 2 * Math.PI / segments.length;
        const a = (i + 0.5) * angleStep + rotation;
        const r = radii.outer * 0.6;
        ctx.save();
        ctx.translate(center.x + Math.cos(a) * r, center.y + Math.sin(a) * r);
        ctx.rotate(a);
        ctx.fillText(seg, 0, 0);
        ctx.restore();
      });
      if (clickPos) {
        ctx.beginPath(); ctx.strokeStyle = 'red'; ctx.lineWidth = 2;
        ctx.moveTo(clickPos.x - 10, clickPos.y);
        ctx.lineTo(clickPos.x + 10, clickPos.y);
        ctx.moveTo(clickPos.x, clickPos.y - 10);
        ctx.lineTo(clickPos.x, clickPos.y + 10);
        ctx.stroke();
      }
    }

    function animate() {
      cancelAnimationFrame(animId);
      if (decelerating) {
        velocity *= DECELERATION;
        if (velocity < STOP_THRESHOLD) {
          decelerating = false; velocity = 0;
          if (clickPos) {
            const mx = clickPos.x - center.x;
            const my = clickPos.y - center.y;
            let lbl = '-';
            if (Math.hypot(mx, my) <= radii.outer) {
              const count = segments.length;
              const angleStep = 2 * Math.PI / count;
              const a = ((Math.atan2(my, mx) - rotation) % (2 * Math.PI) + 2 * Math.PI) % (2 * Math.PI);
              lbl = segments[Math.floor(a / angleStep)];
            }
            document.getElementById('result').textContent = lbl;
            startBtn.disabled = false;
          }
        }
      }
      rotation += velocity;
      drawBoard();
      animId = requestAnimationFrame(animate);
    }

    // 初期化実行
    init();
  </script>
</body>
</html>
