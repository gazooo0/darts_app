<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>る～れっとだーつ！</title>
  <style>
    body { display: flex; flex-direction: column; align-items: center; font-family: sans-serif; margin: 20px; }
    canvas { border: 2px solid #333; border-radius: 8px; background: #fff; cursor: pointer; }
    #result { font-size: 20px; margin-top: 12px; min-height: 24px; }
    #start-control { margin-top: 12px; }
    #start-btn { font-size: 1.2em; padding: 10px 20px; }
    #controls { margin-top: 12px; display: flex; gap: 8px; align-items: center; }
    table#inputs { margin-top: 12px; border-collapse: collapse; }
    table#inputs th, table#inputs td { border: 1px solid #999; padding: 4px 8px; text-align: center; }
    table#inputs th { background: #eee; }
    table#inputs input[type="text"] { width: 100px; border: none; text-align: center; }
    table#inputs input[type="color"] { border: none; width: 30px; height: 20px; padding: 0; }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
  </style>
</head>
<body>
  <canvas id="dartboard" width="400" height="400"></canvas>
  <div id="result"></div>

  <div id="start-control">
    <button id="start-btn">回転スタート</button>
    <span>※回転している円盤をクリックするとターゲットが付き円盤が止まります。</span>
  </div>
  <div id="controls">
    <button id="add-btn">項目を追加</button>
    <button id="update-btn">設定を反映</button>

  </div>

  <table id="inputs">
    <thead>
      <tr>
        <th>Label</th><th>Color</th>
        <th>Label</th><th>Color</th>
        <th>Label</th><th>Color</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>

  <script>
    const canvas = document.getElementById('dartboard');
    const ctx = canvas.getContext('2d');
    const center = { x: canvas.width/2, y: canvas.height/2 };
    const radii = { inner:100, outer:180 };
    let segments = [];
    let colors = [];
    let rotation=0, velocity=0, animId;
    let decelerating=false, clickPos=null;

    const defaultColors = ['#ff6666','#66ff66','#6666ff','#ff66ff','#66ffff','#ffff66','#ff9966','#9966ff','#66ff99','#cc66cc'];
    const tbody = document.querySelector('#inputs tbody');

    document.getElementById('add-btn').addEventListener('click', addEntry);
    function addEntry() {
      const idx = segments.length;
      segments.push((idx+1).toString());
      colors.push(defaultColors[idx % defaultColors.length]);
      rebuildTable();
    }

    function rebuildTable() {
      tbody.innerHTML = '';
      const n = segments.length;
      const cols = 3;
      const rows = Math.ceil(n/cols);
      for (let r = 0; r < rows; r++) {
        const tr = document.createElement('tr');
        for (let c = 0; c < cols; c++) {
          const idx = r*cols + c;
          if (idx < n) {
            // Label cell
            const td1 = document.createElement('td');
            const inText = document.createElement('input');
            inText.type = 'text'; inText.className = 'segment-input'; inText.value = segments[idx];
            td1.appendChild(inText);
            tr.appendChild(td1);
            // Color cell
            const td2 = document.createElement('td');
            const inColor = document.createElement('input');
            inColor.type = 'color'; inColor.className = 'color-input'; inColor.value = colors[idx];
            td2.appendChild(inColor);
            tr.appendChild(td2);
          } else {
            tr.appendChild(document.createElement('td'));
            tr.appendChild(document.createElement('td'));
          }
        }
        tbody.appendChild(tr);
      }
    }

    function parseInputs() {
      segments = Array.from(document.querySelectorAll('.segment-input')).map(i => i.value.trim() || '-');
      colors = Array.from(document.querySelectorAll('.color-input')).map(i => i.value);
      clickPos = null; decelerating = false; velocity = 0;
    }

    function drawBoard() {
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.save(); ctx.translate(center.x, center.y); ctx.rotate(rotation);
      const count = segments.length;
      if (count > 0) {
        const angle = 2 * Math.PI / count;
        for (let i = 0; i < count; i++) {
          ctx.beginPath(); ctx.moveTo(0,0);
          ctx.fillStyle = colors[i];
          ctx.arc(0,0,radii.outer, i*angle, (i+1)*angle);
          ctx.closePath(); ctx.fill();
        }
        ctx.restore();
        ctx.fillStyle = '#000'; ctx.font = '14px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        for (let i = 0; i < count; i++) {
          const a = (i + 0.5) * 2 * Math.PI / count + rotation;
          const r = radii.outer * 0.6;
          const x = center.x + Math.cos(a) * r;
          const y = center.y + Math.sin(a) * r;
          ctx.save(); ctx.translate(x, y); ctx.rotate(a);
          ctx.fillText(segments[i], 0, 0); ctx.restore();
        }
      } else ctx.restore();
      if (clickPos) {
        ctx.beginPath(); ctx.strokeStyle = 'red'; ctx.lineWidth = 2;
        ctx.moveTo(clickPos.x-10, clickPos.y); ctx.lineTo(clickPos.x+10, clickPos.y);
        ctx.moveTo(clickPos.x, clickPos.y-10); ctx.lineTo(clickPos.x, clickPos.y+10);
        ctx.stroke();
      }
    }

    function animate() {
      if (decelerating) {
        velocity *= 0.95;
        if (velocity < 0.02) {
          decelerating = false; velocity = 0;
          if (clickPos) {
            const mx = clickPos.x - center.x, my = clickPos.y - center.y;
            let lbl = '-';
            if (Math.hypot(mx,my) <= radii.outer) {
              const count = segments.length;
              const angle = 2 * Math.PI / count;
              const a = ((Math.atan2(my,mx) - rotation) % (2 * Math.PI) + 2 * Math.PI) % (2 * Math.PI);
              lbl = segments[Math.floor(a / angle)];
            }
            document.getElementById('result').textContent = lbl;
            document.getElementById('start-btn').disabled = false;
          }
        }
      }
      rotation += velocity;
      drawBoard();
      animId = requestAnimationFrame(animate);
    }

    canvas.addEventListener('click', e => {
      if (velocity === 0) return;
      const rect = canvas.getBoundingClientRect();
      clickPos = { x: e.clientX - rect.left, y: e.clientY - rect.top };
      decelerating = true;
    });

    document.getElementById('update-btn').addEventListener('click', () => {
      if (velocity !== 0) return;
      parseInputs(); rebuildTable(); drawBoard(); document.getElementById('result').textContent = '';
    });
    document.getElementById('start-btn').addEventListener('click', () => {
      parseInputs(); velocity = 0.3; decelerating = false;
      document.getElementById('start-btn').disabled = true;
      animate();
    });

    // 初期3行追加
    addEntry(); addEntry(); addEntry();
    rebuildTable(); drawBoard(); animate();
  </script>
</body>
</html>
