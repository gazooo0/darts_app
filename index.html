<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>る～れっとだーつ！</title>
  <style>
    body { display: flex; flex-direction: column; align-items: center; font-family: sans-serif; margin: 20px; }
    canvas { border: 2px solid #333; border-radius: 8px; background: #fff; cursor: pointer; }
    #result { font-size: 20px; margin-top: 12px; min-height: 24px; }
    #start-control { margin-top: 12px; }
    #start-btn { font-size: 1.2em; padding: 10px 20px; }
    #controls { margin-top: 12px; display: flex; gap: 8px; justify-content: center; align-items: center; }
    table#inputs { margin-top: 12px; border-collapse: collapse; }
    table#inputs th, table#inputs td { border: 1px solid #999; padding: 4px 8px; text-align: center; }
    table#inputs th { background: #eee; }
    table#inputs input[type="text"] { width: 100px; border: none; text-align: center; }
    table#inputs input[type="color"] { border: none; width: 30px; height: 20px; padding: 0; }
    #credits { font-size: 12px; color: #666; margin-top: 8px; }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
  </style>
</head>
<body>
  <!-- 音声素材 -->
  <audio id="drumroll" src="drumroll.mp3" loop></audio>
  <audio id="stopSound" src="stop.mp3"></audio>

  <canvas id="dartboard" width="400" height="400"></canvas>
  <div id="result"></div>

  <div id="start-control">
    <button id="start-btn">Start</button>
  </div>
  <div id="controls">
    <button id="add-btn">行追加</button>
    <button id="update-btn">更新</button>
    <span>※円をクリックで徐々に停止</span>
  </div>

  <table id="inputs">
    <thead>
      <tr><th>Label</th><th>Color</th><th>Label</th><th>Color</th><th>Label</th><th>Color</th></tr>
    </thead>
    <tbody></tbody>
  </table>

  <div id="credits">使用素材：効果音工房様・効果音ラボ様</div>

  <script>
    // DOM キャッシュ
    const canvas = document.getElementById('dartboard');
    const ctx = canvas.getContext('2d');
    const center = { x: canvas.width/2, y: canvas.height/2 };
    const radii = { inner:100, outer:180 };
    const drum = document.getElementById('drumroll');
    const stopSound = document.getElementById('stopSound');
    const tbody = document.querySelector('#inputs tbody');
    const startBtn = document.getElementById('start-btn');
    const addBtn = document.getElementById('add-btn');
    const updateBtn = document.getElementById('update-btn');

    // 状態
    let segments = [];
    let colors = [];
    let rotation = 0;
    let velocity = 0;
    let decelerating = false;
    let clickPos = null;
    let animId;

    const defaultColors = ['#ff6666','#66ff66','#6666ff','#ff66ff','#66ffff','#ffff66','#ff9966','#9966ff','#66ff99','#cc66cc'];
    const DECELERATION = 0.95;
    const STOP_THRESHOLD = 0.02;
    const INITIAL_COUNT = 3;

    function init() {
      segments = [];
      colors = [];
      for (let i = 0; i < INITIAL_COUNT; i++) addEntry();
      rebuildTable();
      drawBoard();
      animate();
      bindEvents();
    }

    function bindEvents() {
      addBtn.addEventListener('click', addEntry);
      updateBtn.addEventListener('click', () => {
        if (velocity !== 0) return;
        parseInputs(); rebuildTable(); drawBoard();
        document.getElementById('result').textContent = '';
      });
      startBtn.addEventListener('click', () => {
        parseInputs(); velocity = 0.3; decelerating = false;
        drum.currentTime = 0; drum.play().catch(() => {});
        startBtn.disabled = true;
        cancelAnimationFrame(animId);
        animate();
      });
      canvas.addEventListener('click', e => {
        if (velocity === 0) return;
        // ドラムロール停止、停止音再生
        drum.pause(); drum.currentTime = 0;
        stopSound.currentTime = 0; stopSound.play().catch(() => {});
        const rect = canvas.getBoundingClientRect();
        clickPos = { x: e.clientX - rect.left, y: e.clientY - rect.top };
        decelerating = true;
      });
    }

    function addEntry() {
      const idx = segments.length;
      segments.push((idx + 1).toString());
      colors.push(defaultColors[idx % defaultColors.length]);
      rebuildTable();
    }

    function rebuildTable() {
      tbody.innerHTML = '';
      const cols = 3;
      for (let i = 0; i < segments.length; i += cols) {
        const tr = document.createElement('tr');
        for (let j = 0; j < cols; j++) {
          const idx = i + j;
          if (idx < segments.length) {
            tr.innerHTML += `
              <td><input class="segment-input" type="text" value="${segments[idx]}"></td>
              <td><input class="color-input" type="color" value="${colors[idx]}"></td>
            `;
          } else {
            tr.innerHTML += '<td></td><td></td>';
          }
        }
        tbody.appendChild(tr);
      }
    }

    function parseInputs() {
      const segEls = document.querySelectorAll('.segment-input');
      const colEls = document.querySelectorAll('.color-input');
      segments = Array.from(segEls).map(el => el.value.trim() || '-');
      colors = Array.from(colEls).map(el => el.value);
      clickPos = null;
      decelerating = false;
      velocity = 0;
    }

    function drawBoard() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.save(); ctx.translate(center.x, center.y); ctx.rotate(rotation);
      const count = segments.length;
      if (count) {
        const angleStep = 2 * Math.PI / count;
        segments.forEach((seg, i) => {
          ctx.beginPath();
          ctx.fillStyle = colors[i];
          ctx.moveTo(0, 0);
          ctx.arc(0, 0, radii.outer, i * angleStep, (i + 1) * angleStep);
          ctx.closePath(); ctx.fill();
        });
      }
      ctx.restore();
      ctx.fillStyle = '#000'; ctx.font = '14px sans-serif';
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      segments.forEach((seg, i) => {
        const angleStep = 2 * Math.PI / segments.length;
        const a = (i + 0.5) * angleStep + rotation;
        const r = radii.outer * 0.6;
        ctx.save();
        ctx.translate(center.x + Math.cos(a) * r, center.y + Math.sin(a) * r);
        ctx.rotate(a);
        ctx.fillText(seg, 0, 0);
        ctx.restore();
      });
      if (clickPos) {
        ctx.beginPath(); ctx.strokeStyle = 'red'; ctx.lineWidth = 2;
        ctx.moveTo(clickPos.x - 10, clickPos.y);
        ctx.lineTo(clickPos.x + 10, clickPos.y);
        ctx.moveTo(clickPos.x, clickPos.y - 10);
        ctx.lineTo(clickPos.x, clickPos.y + 10);
        ctx.stroke();
      }
    }

    function animate() {
      if (decelerating) {
        velocity *= DECELERATION;
        if (velocity < STOP_THRESHOLD) {
          decelerating = false; velocity = 0;
          if (clickPos) {
            const mx = clickPos.x - center.x;
            const my = clickPos.y - center.y;
            let lbl = '-';
            if (Math.hypot(mx, my) <= radii.outer) {
              const count = segments.length;
              const angleStep = 2 * Math.PI / count;
              const a = ((Math.atan2(my, mx) - rotation) % (2 * Math.PI) + 2 * Math.PI) % (2 * Math.PI);
              lbl = segments[Math.floor(a / angleStep)];
            }
            document.getElementById('result').textContent = lbl;
            startBtn.disabled = false;
          }
        }
      }
      rotation += velocity;
      drawBoard();
      animId = requestAnimationFrame(animate);
    }

    init();
  </script>
</body>
</html>
